#
# Copyright (C) OpenCyphal Development Team  <opencyphal.org>
# Copyright Amazon.com Inc. or its affiliates.
# SPDX-License-Identifier: MIT
#

cmake_minimum_required(VERSION 3.27.0 FATAL_ERROR)


set(NUNAVUT_VERSION "3.0")


####### Created using @PACKAGE_INIT@ by configure_package_config_file() #######

get_filename_component(PACKAGE_PREFIX_DIR "${CMAKE_CURRENT_LIST_DIR}/" ABSOLUTE)

macro(set_and_check _var _file)
  set(${_var} "${_file}")
  if(NOT EXISTS "${_file}")
    message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
  endif()
endmacro()

macro(check_required_components _NAME)
  foreach(comp ${${_NAME}_FIND_COMPONENTS})
    if(NOT ${_NAME}_${comp}_FOUND)
      if(${_NAME}_FIND_REQUIRED_${comp})
        set(${_NAME}_FOUND FALSE)
      endif()
    endif()
  endforeach()
endmacro()

####################################################################################

find_package(Python3 3.9 REQUIRED)

set_and_check(NUNAVUT_SOURCE_DIR "${PACKAGE_PREFIX_DIR}/src")

check_required_components(Nunavut Python3)

execute_process(
        COMMAND ${Python3_EXECUTABLE} ${PACKAGE_PREFIX_DIR}/.github/verify.py --major-minor-version-only
        OUTPUT_VARIABLE NUNAVUT_VERSION_MAJOR_MINOR
        OUTPUT_STRIP_TRAILING_WHITESPACE
        WORKING_DIRECTORY "${PACKAGE_PREFIX_DIR}"
)

execute_process(
        COMMAND ${Python3_EXECUTABLE} ${PACKAGE_PREFIX_DIR}/.github/verify.py --version-only
        OUTPUT_VARIABLE NUNAVUT_VERSION
        OUTPUT_STRIP_TRAILING_WHITESPACE
        WORKING_DIRECTORY "${PACKAGE_PREFIX_DIR}"
)

message(STATUS "Nunavut version: ${NUNAVUT_VERSION}")

# Taken from https://stackoverflow.com/questions/32585927/proper-way-to-use-platform-specific-separators-in-cmake as
# this issue (https://gitlab.kitware.com/cmake/cmake/-/issues/17946) is still open.
if("${CMAKE_HOST_SYSTEM}" MATCHES ".*Windows.*")
  set(NUNAVUT_PATH_LIST_SEP "\\;")
else() # e.g. Linux
  set(NUNAVUT_PATH_LIST_SEP ":")
endif()

# function: add_cyphal_library
# Create a library built from code generated by the Nunavut tool from dsdl files. This version
# of the function always defines an interface library since c and c++ types are generated as header-only.
#
# param: NAME str                               - A name for the library. If EXACT_NAME is set then this is the
#                                                 exact name of the target. Otherwise, the target name will be
#                                                 derived from this name for uniqueness. Use OUT_TARGET to capture
#                                                 the generated name of the library target.
# param: LANGUAGE str                           - The language to generate code for. Supported types are 'c' and 'cpp'.
# param: DSDL_FILES list[path]                  - A list of DSDL files to generate code for.
# param: DSDL_NAMESPACES optional list[path]    - A list of namespaces to search for dependencies in. While optional,
#                                                 it's rare that this would be omitted.
# param: LANGUAGE_STANDARD optional str         - The language standard to use.
# param: OUTPUT_DIR optional path               - The directory to write generated code to. If omitted then
#                                                 ${CMAKE_CURRENT_BINARY_DIR}/generated is used.
# param: CONFIGURATION optional list[path]      - A list of configurations files to pass into nnvg. See the
#                                                 nunavut documentation for more information about configuration
#                                                 files.
# param: WORKING_DIRECTORY optional path        - The working directory to use when invoking the Nunavut tool. If
#                                                 omitted then ${CMAKE_CURRENT_SOURCE_DIR} is used.
# param: PYDSDL_PATH optional path              - The path to the PyDSDL tool. If omitted then it must be available
#                                                 to python when invoked.
# param: FILE_EXTENSION optional str            - The file extension to use for generated files. If omitted then
#                                                 the default for the language is used.
# option: ALLOW_EXPERIMENTAL_LANGUAGES          - If set then unsupported languages will be allowed.
# option: CONSOLE_DEBUG                         - If set then verbose output will be enabled.
# option: SUPPORT_ONLY                          - If set then the library created will contain only support code needed
#                                                 to use the code generated for DSDL_FILES. This allows different
#                                                 cyphal libraries to share a single set of support headers and
#                                                 avoids duplicate target rules.
# option: EXACT_NAME                            - If set then the target name will be exactly as specified in NAME.
#                                                 Otherwise, the target name will be prefixed with an internal default.
# param: OUT_LIBRARY_TARGET optional variable   - If set, this method write a variable named ${OUT_LIBRARY_TARGET} with
#                                                 the interface library target name defined for the library in the
#                                                 calling scope.
# param: OUT_CODEGEN_TARGET optional variable   - If set, this method write a variable named ${OUT_CODEGEN_TARGET} with
#                                                 the custom target name defined for invoking the code generator.
function (add_cyphal_library)
    #+-[input]----------------------------------------------------------------+
    set(options ALLOW_EXPERIMENTAL_LANGUAGES CONSOLE_DEBUG SUPPORT_ONLY EXACT_NAME)
    set(singleValueArgs
        NAME
            OUT_LIBRARY_TARGET
            OUT_CODEGEN_TARGET
            LANGUAGE
            OUTPUT_DIR
            LANGUAGE_STANDARD
            PYDSDL_PATH
            WORKING_DIRECTORY
            FILE_EXTENSION
    )
    set(multiValueArgs DSDL_FILES DSDL_NAMESPACES)
    cmake_parse_arguments(PARSE_ARGV 0 ARG "${options}" "${singleValueArgs}" "${multiValueArgs}")

    if (NOT ARG_NAME AND EXACT_NAME)
        message(FATAL_ERROR "add_cyphal_library: NAME is required if EXACT_NAME is set.")
    endif()

    if (NOT ARG_LANGUAGE)
        message(FATAL_ERROR "add_cyphal_library: LANGUAGE is required.")
    endif()

    if (${ARG_LANGUAGE} STREQUAL "cpp")
        if (NOT ARG_ALLOW_EXPERIMENTAL_LANGUAGES)
            message(FATAL_ERROR "add_cyphal_library: C++ support is experimental and must be enabled by setting the ALLOW_EXPERIMENTAL_LANGUAGES option.")
        endif()
    elseif (NOT ${ARG_LANGUAGE} STREQUAL "c")
        message(FATAL_ERROR "add_cyphal_library: LANGUAGE must be 'c' or 'cpp'.")
    endif()

    if (NOT ARG_DSDL_FILES)
        message(FATAL_ERROR "add_cyphal_library: DSDL_FILES is required.")
    endif()

    if (NOT ARG_OUTPUT_DIR)
        set(ARG_OUTPUT_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated")
    endif()

    if (NOT ARG_WORKING_DIRECTORY)
        set(ARG_WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
    endif()

    if (ARG_UNPARSED_ARGUMENTS)
        message(FATAL_ERROR "add_cyphal_library: Unknown arguments found: ${ARG_UNPARSED_ARGUMENTS}\n"
        "USAGE: \n"
        "  add_cyphal_library(\n"
        "    NAME <name> LANGUAGE <language> DSDL_FILES <dsdl_files> [DSDL_NAMESPACES <dsdl_namespaces>]\n"
        "    [LANGUAGE_STANDARD <language_standard>] [OUTPUT_DIR <output_dir>] [CONFIGURATION <configuration>]\n"
        "    [WORKING_DIRECTORY <working_directory>] [PYDSDL_PATH <pydsdl_path>] [FILE_EXTENSION <file_extension>]\n"
        "    [ALLOW_EXPERIMENTAL_LANGUAGES] [CONSOLE_DEBUG] [SUPPORT_ONLY] [EXACT_NAME]\n"
        "    [OUT_LIBRARY_TARGET <out_library_target>] [OUT_CODEGEN_TARGET <out_codegen_target>]\n"
        "  )\n"
        )
    endif()

    #+-[body]-----------------------------------------------------------------+

    if (ARG_EXACT_NAME)
        set(LOCAL_TARGET_NAME "${ARG_NAME}")
    else()
        if (NOT ARG_NAME)
            set(ARG_NAME "")
        else()
            set(ARG_NAME "-${ARG_NAME}")
        endif()
        if (ARG_SUPPORT_ONLY)
            set(LOCAL_TARGET_NAME "cyphal-support${ARG_NAME}")
        else()
            set(LOCAL_TARGET_NAME "cyphal-types${ARG_NAME}")
        endif()
    endif()

    # handle forming arguments for the nunavut tool based on arguments passed into this function.
    set(LOCAL_DYNAMIC_ARGS "")
    if (ARG_DSDL_NAMESPACES)
        foreach(LOCAL_DSDL_NAMESPACE IN LISTS ARG_DSDL_NAMESPACES)
            list(APPEND LOCAL_DYNAMIC_ARGS "--lookup-dir" "${LOCAL_DSDL_NAMESPACE}")
        endforeach()
    endif()

    if (ARG_LANGUAGE_STANDARD)
        list(APPEND LOCAL_DYNAMIC_ARGS "--language-standard" "${ARG_LANGUAGE_STANDARD}")
    endif()

    if (ARG_CONFIGURATIONS)
        foreach(LOCAL_CONFIGURATION IN LISTS ARG_CONFIGURATIONS)
            list(APPEND LOCAL_DYNAMIC_ARGS "--configuration" "${LOCAL_CONFIGURATION}")
        endforeach()
    endif()

    if (ARG_ALLOW_EXPERIMENTAL_LANGUAGES)
        list(APPEND LOCAL_DYNAMIC_ARGS "--include-experimental-languages")
    endif()

    if (ARG_SUPPORT_ONLY)
        list(APPEND LOCAL_DYNAMIC_ARGS "--generate-support" "only")
    endif()

    if (ARG_FILE_EXTENSION)
        list(APPEND LOCAL_DYNAMIC_ARGS "--output-extension" "${ARG_FILE_EXTENSION}")
    endif()

    # Setup running nunavut and pydsdl from source
    set(LOCAL_PYTHON_PATH "${NUNAVUT_SOURCE_DIR}")

    if (ARG_PYDSDL_PATH)
        set(LOCAL_PYTHON_PATH "${LOCAL_PYTHON_PATH}${NUNAVUT_PATH_LIST_SEP}${ARG_PYDSDL_PATH}")
    endif()

    set(ENV{PYTHONPATH} ${LOCAL_PYTHON_PATH})

    # Setup additional debug options if requested.
    set(LOCAL_DEBUG_COMMAND_OPTIONS "")
    if (ARG_CONSOLE_DEBUG)
        list(APPEND LOCAL_DEBUG_COMMAND_OPTIONS "COMMAND_ECHO" "STDOUT" "ECHO_OUTPUT_VARIABLE")
    endif()

    # List all inputs to use as the dependencies for the custom command.
    execute_process(
        COMMAND
            ${Python3_EXECUTABLE} -m nunavut
            --target-language ${ARG_LANGUAGE}
            --list-inputs
            --dry-run
            ${LOCAL_DYNAMIC_ARGS}
            ${ARG_DSDL_FILES}
        ${LOCAL_DEBUG_COMMAND_OPTIONS}
        WORKING_DIRECTORY ${ARG_WORKING_DIRECTORY}
        OUTPUT_VARIABLE LOCAL_LIB_INPUTS
        OUTPUT_STRIP_TRAILING_WHITESPACE
        ENCODING UTF8
    )

    list(LENGTH LOCAL_LIB_INPUTS LOCAL_LIB_INPUTS_LENGTH)
    if (${LOCAL_LIB_INPUTS_LENGTH} EQUAL 0)
        message(FATAL_ERROR "add_cyphal_library: No input files found for ${LOCAL_TARGET_NAME} (${LOCAL_LIB_INPUTS}).")
    endif()

    if (ARG_CONSOLE_DEBUG)
        message(STATUS "\nadd_cyphal_library: Found input files: ${LOCAL_LIB_INPUTS}")
    endif()

    # List all outputs to use as the outputs for the custom command.
    execute_process(
        COMMAND
            ${Python3_EXECUTABLE} -m nunavut
            --target-language ${ARG_LANGUAGE}
            --list-outputs
            --dry-run
            --outdir ${ARG_OUTPUT_DIR}
            ${LOCAL_DYNAMIC_ARGS}
            ${ARG_DSDL_FILES}
        ${LOCAL_DEBUG_COMMAND_OPTIONS}
        WORKING_DIRECTORY ${ARG_WORKING_DIRECTORY}
        OUTPUT_VARIABLE LOCAL_LIB_OUTPUTS
        OUTPUT_STRIP_TRAILING_WHITESPACE
        ENCODING UTF8
    )

    list(LENGTH LOCAL_LIB_OUTPUTS LOCAL_LIB_OUTPUTS_LENGTH)
    if (${LOCAL_LIB_OUTPUTS_LENGTH} EQUAL 0)
        message(FATAL_ERROR "add_cyphal_library: No output files found for ${LOCAL_TARGET_NAME}.")
    endif()

    if (ARG_CONSOLE_DEBUG)
        message(STATUS "\nadd_cyphal_library: Found output files: ${LOCAL_LIB_OUTPUTS}")
    endif()

    # Create the custom command to generate source files.
    add_custom_command(
        OUTPUT ${LOCAL_LIB_OUTPUTS}
        COMMAND
            export PYTHONPATH=${LOCAL_PYTHON_PATH} && ${Python3_EXECUTABLE} -m nunavut
            --target-language ${ARG_LANGUAGE}
            --outdir ${ARG_OUTPUT_DIR}
            ${LOCAL_DYNAMIC_ARGS}
            ${ARG_DSDL_FILES}
        WORKING_DIRECTORY ${ARG_WORKING_DIRECTORY}
        DEPENDS ${LOCAL_LIB_INPUTS}
    )

    set(LOCAL_CODEGEN_TARGET "${LOCAL_TARGET_NAME}-generate")
    add_custom_target(${LOCAL_CODEGEN_TARGET}
        DEPENDS ${LOCAL_LIB_OUTPUTS}
    )

    # finally, define the interface library for the generated headers.
    add_library(${LOCAL_TARGET_NAME} INTERFACE ${LOCAL_LIB_OUTPUTS})

    target_include_directories(${LOCAL_TARGET_NAME} INTERFACE ${ARG_OUTPUT_DIR})

    add_dependencies(${LOCAL_TARGET_NAME} ${LOCAL_CODEGEN_TARGET})

    if (ARG_CONSOLE_DEBUG)
        message(STATUS "add_cyphal_library: Done adding library ${LOCAL_TARGET_NAME}.")
    endif()

    #+-[output]---------------------------------------------------------------+
    if (ARG_OUT_LIBRARY_TARGET)
        set(${ARG_OUT_LIBRARY_TARGET} ${LOCAL_TARGET_NAME} PARENT_SCOPE)
    endif()

    if (ARG_OUT_CODEGEN_TARGET)
        set(${ARG_OUT_CODEGEN_TARGET} ${LOCAL_CODEGEN_TARGET} PARENT_SCOPE)
    endif()
endfunction()
