#!/usr/bin/env python3
#
# Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# Copyright (C) 2018-2019  UAVCAN Development Team  <uavcan.org>
# This software is distributed under the terms of the MIT License.
#
"""
    Command-line script for using pydsdlgen and jinja to generate code
    from dsdl definitions.
"""

import argparse
import logging
import os
import pathlib
import sys
import typing


def _run(args: argparse.Namespace, extra_includes: str) -> int:
    '''
        Post command-line setup and parsing logic to execute pydsdlgen
        library routines based on input.
    '''
    #
    # pydsdlgen : load module
    #
    from pydsdl import read_namespace
    from pydsdlgen import build_namespace_tree
    from pydsdlgen.jinja import Generator

    #
    # pydsdlgen : parse
    #
    type_map = read_namespace(args.root_namespace, extra_includes)

    root_namespace = build_namespace_tree(
        type_map,
        args.root_namespace,
        args.outdir,
        args.output_extension,
        args.namespace_output_stem)

    #
    # pydsdlgen : generate
    #

    if args.list_outputs:
        for _, output_path in root_namespace.get_all_datatypes():
            sys.stdout.write(str(output_path))
            sys.stdout.write(';')
        return 0

    generator = Generator(root_namespace,
                          args.generate_namespace_types,
                          pathlib.Path(args.templates))

    if args.list_inputs:
        for input_path in generator.get_templates():
            sys.stdout.write(str(input_path.resolve()))
            sys.stdout.write(';')
        if args.generate_namespace_types:
            for output_type, _ in root_namespace.get_all_types():
                sys.stdout.write(str(output_type.source_file_path))
                sys.stdout.write(';')
        else:
            for output_type, _ in root_namespace.get_all_datatypes():
                sys.stdout.write(str(output_type.source_file_path))
                sys.stdout.write(';')
        return 0

    if not args.list_outputs and not args.list_inputs:
        return generator.generate_all(args.dry_run)
    else:
        return 0


class _LazyVersionAction(argparse._VersionAction):
    '''
    Changes argparse._VersionAction so we only load pydsdlgen.version
    if the --version action is requested.
    '''

    def __call__(self,
                 parser: argparse.ArgumentParser,
                 namespace: argparse.Namespace,
                 values: typing.Any,
                 option_string: typing.Optional[str] = None) -> None:
        from pydsdlgen.version import __version__
        version_string = '.'.join(map(str, __version__))
        formatter = parser._get_formatter()
        formatter.add_text(version_string)
        parser._print_message(formatter.format_help(), sys.stdout)
        parser.exit()


def _make_parser() -> argparse.ArgumentParser:
    """
        Defines the command-line interface. Provided as a separate factory method to
        support sphinx-argparse documentation.
    """

    epilog = '''**Example Usage**::

    # This would include j2 templates for a folder named 'c_jinja'
    # and generate .h files into a directory named 'include' using
    # dsdl root namespaces found under a folder named 'dsdl'.

    %(prog)s --outdir include --templates c_jinja -e .h dsdl

----
'''

    parser = argparse.ArgumentParser(
        description='Generate code from UAVCAN DSDL using pydsdl and jinja2',
        epilog=epilog,
        formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('root_namespace',
                        help='A source directory with DSDL definitions.')

    parser.add_argument('--lookup-dir', '-I', default=[], action='append',
                        help='''List of other namespace directories containing data type definitions that are
referred to from the target root namespace. For example, if you are reading a
vendor-specific namespace, the list of lookup directories should always include
a path to the standard root namespace "uavcan", otherwise the types defined in
the vendor-specific namespace won't be able to use data types from the standard
namespace.

Additional directories can also be specified through the environment variable
UAVCAN_DSDL_INCLUDE_PATH, where the path entries are
separated by colons ":"'''
                        )

    parser.add_argument('--verbose', '-v', action='count',
                        help='verbosity level (-v, -vv)')

    parser.add_argument('--version', action=_LazyVersionAction)

    parser.add_argument(
        '--outdir', '-O', default='pydsdlgen_out', help='output directory')

    parser.add_argument('--templates',
                        required='--list-outputs' not in sys.argv,
                        help='A path to a directory containing templates to use when generating code.')

    def extension_type(raw_arg: str) -> str:
        if len(raw_arg) > 0 and not raw_arg.startswith('.'):
            return '.' + raw_arg
        else:
            return raw_arg

    parser.add_argument('--output-extension', '-e', default='', type=extension_type,
                        required='--list-inputs' not in sys.argv,
                        help='The extension to use for generated files.')

    parser.add_argument('--dry-run', '-d', action='store_true',
                        help='If True then no files will be generated.')

    parser.add_argument('--list-outputs', action='store_true',
                        help='''Emit a semicolon-separated list of files.
(implies --dry-run)
Emits files that would be generated if invoked without --dry-run.
This command is useful for integrating with CMake and other build
systems that need a list of targets to determine if a rebuild is
necessary.'''
                        )

    parser.add_argument('--list-inputs', action='store_true',
                        help='''Emit a semicolon-separated list of files.
(implies --dry-run)
A list of files that are resolved given input arguments like templates.
This command is useful for integrating with CMake and other build systems
that need a list of inputs to determine if a rebuild is necessary.'''
                        )

    parser.add_argument('--generate-namespace-types',
                        action='store_true',
                        help='''If enabled this script will generate source for namespaces.
All namespaces including and under the root namespace will be treated as a
pseudo-type and the appropriate template will be used. The generator will
first look for a template with the stem "Namespace" and will then use the
"Any" template if that is available. The name of the output file will be
the default value for the --namespace-output-stem argument and can be
changed using that argument.
'''
                        )

    parser.add_argument('--namespace-output-stem',
                        default='Namespace',
                        help='The name of the file generated when --generate-namespace-types is provided.')

    return parser


def main() -> int:
    """
        Main entry point for this program.
    """

    #
    # Parse the command-line arguments.
    #
    args = _make_parser().parse_args()

    #
    # Setup Python logging.
    #
    fmt = '%(message)s'
    level = {0: logging.WARNING, 1: logging.INFO,
             2: logging.DEBUG}.get(args.verbose or 0, logging.DEBUG)
    logging.basicConfig(stream=sys.stderr, level=level, format=fmt)

    logging.info('Running %s using sys.prefix: %s',
                 pathlib.Path(__file__).name, sys.prefix)

    #
    # Parse UAVCAN_DSDL_INCLUDE_PATH
    #
    extra_includes = args.lookup_dir

    try:
        extra_includes_from_env = os.environ['UAVCAN_DSDL_INCLUDE_PATH'].split(':')

        if len(extra_includes_from_env) > 0:
            logging.info('Additional include directories from UAVCAN_DSDL_INCLUDE_PATH: %s',
                         str(extra_includes_from_env))
            extra_includes += extra_includes_from_env
    except KeyError:
        pass

    return _run(args, extra_includes)


if __name__ == "__main__":
    main()
