#!/usr/bin/env python3
#
# Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# Copyright (C) 2018-2019  UAVCAN Development Team  <uavcan.org>
# This software is distributed under the terms of the MIT License.
#

import argparse
import logging
import os
import sys


def main() -> int:
    #
    # Command-line interface
    #
    parser = argparse.ArgumentParser(
        description='Transpiles UAVCAN DSDL types into C++ types using pydsdl',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('root_namespaces', nargs='+',
                        help='source directories with DSDL definitions')

    parser.add_argument('--verbose', '-v', action='count',
                        help='verbosity level (-v, -vv)')

    parser.add_argument(
        '--outdir', '-O', default='dsdl2cpp_out', help='output directory')

    parser.add_argument('--templates',
                        required='--list-outputs' not in sys.argv,
                        help="Working on this one...")

    parser.add_argument('--pydsdl-path', help='''The path to the pydsdl python source. 
        If not provided or if pydsdl could not be found at this location then
        it must be on the PYTHONPATH.''')

    parser.add_argument('--incdir', '-I', default=[], action='append', help='''nested 
        type namespaces, one path per argument. Can be also specified through the environment variable
        UAVCAN_DSDL_INCLUDE_PATH, where the path entries are separated by colons ":"''')

    def extension_type(raw_arg: str) -> str:
        if not raw_arg.startswith('.'):
            return '.' + raw_arg
        else:
            return raw_arg

    parser.add_argument('--cpp-header-extension', default='.hpp', type=extension_type,
                        help='The extension to use for generated C++ headers.')

    parser.add_argument('--dry-run', '-d', action="store_true",
                        help="If True then no files will be generated.")

    parser.add_argument('--list-outputs', action="store_true",
                        help='''(implies --dry-run) Emit a semicolon-separated list of files that
        would be generated if invoked without --dry-run.
        This command is useful for integrating with CMake and other build systems that need a list
        of targets to determine if a rebuild is necessary.
        ''')

    parser.add_argument('--list-inputs', action="store_true",
                        help='''(implies --dry-run) Emit a semicolon-separated list of files that
        are resolved given input arguments like templates.
        This command is useful for integrating with CMake and other build systems that need a list
        of inputs to determine if a rebuild is necessary.
        ''')

    args = parser.parse_args()

    #
    # No-install support
    #
    if hasattr(args, "pydsdl_path") and args.pydsdl_path is not None and os.path.isdir(args.pydsdl_path):
        sys.path.insert(0, args.pydsdl_path)

    #
    # Parse UAVCAN_DSDL_INCLUDE_PATH
    #
    extra_includes = args.incdir

    try:
        extra_includes_from_env = os.environ['UAVCAN_DSDL_INCLUDE_PATH'].split(
            ':')
        if len(extra_includes_from_env) > 0:
            logging.info('Additional include directories from UAVCAN_DSDL_INCLUDE_PATH: %s', str(
                extra_includes_from_env))
            extra_includes += extra_includes_from_env
    except KeyError:
        pass

    #
    # Python logging
    #
    fmt = '%(message)s'
    level = {0: logging.WARNING, 1: logging.INFO,
             2: logging.DEBUG}.get(args.verbose or 0, logging.DEBUG)
    logging.basicConfig(stream=sys.stderr, level=level, format=fmt)

    #
    # dsdl2cpp : load module
    #
    from libdsdl2cpp import parse_all
    from libdsdl2cpp.generators import Jinja2Generator

    #
    # dsdl2cpp : parse
    #
    parser_result = parse_all(
        args.root_namespaces, extra_includes, args.outdir, args.cpp_header_extension)

    #
    # dsdl2cpp : generate
    #
    
    if args.list_outputs:
        for output_path in parser_result.values():
            sys.stdout.write(str(output_path))
            sys.stdout.write(';')
        return 0

    generator = Jinja2Generator(args.outdir, parser_result, args.templates)
    
    if args.list_inputs:
        for input_path in generator.get_templates():
            sys.stdout.write(str(input_path.resolve()))
            sys.stdout.write(';')
        for output_type in parser_result.keys():
            sys.stdout.write(str(output_type.source_file_path))
            sys.stdout.write(';')
        return 0
    
    if not args.list_outputs and not args.list_inputs:
        return generator.generate_all(args.dry_run)

if __name__ == "__main__":
    main()
