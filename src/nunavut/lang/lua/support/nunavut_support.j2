{#-
 # Copyright (c) 2024 OpenCyphal
 # This software is distributed under the terms of the MIT License.
 # Author: Erik Rainey <erik.rainey@gmail.com>
-#}

-- Nunavut Support Library Function for Decoding Primitives in Lua

local function decode_payload_uint8(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint16(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint24(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint32(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint40(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint48(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint56(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_uint64(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_uint64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int8(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int16(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int24(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int32(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int40(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int48(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int56(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_int64(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_int64()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_float(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_float()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_double(field, payload, offset, field_size, tree)
    tvb = payload(offset, field_size)
    value = tvb:le_float()
    tree:add_le(field, tvb, value)
    return field_size
end

local function decode_payload_bool(field, payload, offset, field_size, tree)
    local offset = 0
    local field_size = 1
    local bits = payload(offset, 1):le_uint()
    local value = bit.band(bits, 0x1)
    tree:add_le(field, bits, value)
    return field_size
end

local function decode_payload_mask(field, byte_array, pinfo, tree, functor)
    -- we assume the payload has be narrowed to the right value for the mask array
    -- the functor must be of the form function(field, byte_array, pinfo, tree, byte_offset, bit_index)
    -- only set mask bits will be called.
    for i = 1, byte_array:len() do
        for j = 1, 8 do
            local mask = bit.lshift(1, j - 1)
            local value = byte_array(i - 1, 1):le_uint()
            local bit = bit.band(value, mask)
            if bit > 0 then -- if any bit set
                local bit_index = (8 * (i - 1)) + (j - 1)
                functor(field, byte_array, pinfo, tree, i - 1, bit_index)
            end
        end
    end
end

return {
    as_uint8 = decode_payload_uint8,
    as_uint16 = decode_payload_uint16,
    as_uint24 = decode_payload_uint24,
    as_uint32 = decode_payload_uint32,
    as_uint40 = decode_payload_uint40,
    as_uint48 = decode_payload_uint48,
    as_uint56 = decode_payload_uint56,
    as_uint64 = decode_payload_uint64,
    as_int8 = decode_payload_int8,
    as_int16 = decode_payload_int16,
    as_int24 = decode_payload_int24,
    as_int32 = decode_payload_int32,
    as_int40 = decode_payload_int40,
    as_int48 = decode_payload_int48,
    as_int56 = decode_payload_int56,
    as_int64 = decode_payload_int64,
    as_float = decode_payload_float,
    as_double = decode_payload_double,
    as_bool = decode_payload_bool,
    as_bool_array = decode_payload_mask,
}
