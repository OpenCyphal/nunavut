{#
type - the current Type
field - the ProtoField of the Type
offset - the current offset
_delimiter_ - if a delimiter is used, this will be set to the extent of the field.
field_size - used to store either the extent or the delimited size
payload - The tvb
pinfo - The packet info
subtree - The current level of the tree structure
#}
{%- if field.data_type is VoidType %}
    -- void type
    offset = offset + {{ field.data_type | to_serialized_length }}
{%- elif field.data_type is BooleanType %}
    -- boolean type
    offset = offset + nunavut_support.as_bool(
            {{ type | full_reference_name }}.{{ field.name }},
            payload, offset, subtree) -- , "{{ field.name }}")
{%- elif field.data_type is PrimitiveType %}
    -- primitive type {{ field.data_type }}
{%- if type.constants %}
    -- Field may use enumerated constants
    do
        local tvb = payload(offset, {{ field.data_type | to_serialized_length }})
        local value = tvb:le_{{ field.data_type | to_wireshark_type }}()
        local enum_name = nil
        -- Look up constant name
{%- set ns = namespace(first=true) %}
{%- for constant in type.constants %}
{%- if ns.first %}
        if value == {{ constant.name }} then
            enum_name = "{{ constant.name }}"
{%- set ns.first = false %}
{%- else %}
        elseif value == {{ constant.name }} then
            enum_name = "{{ constant.name }}"
{%- endif %}
{%- endfor %}
        end
        if enum_name then
            subtree:add_le({{ type | full_reference_name }}.{{ field.name }}, tvb, value, string.format("{{field.name}}: %s (%s)", tostring(value), enum_name))
        else
            subtree:add_le({{ type | full_reference_name }}.{{ field.name }}, tvb, value)
        end
        offset = offset + {{ field.data_type | to_serialized_length }}
    end
{%- else %}
    offset = offset + nunavut_support.as_{{ field.data_type | to_protofield_type }}(
            {{ type | full_reference_name }}.{{ field.name }},
            payload, offset, {{ field.data_type | to_serialized_length }},
            subtree) -- , "{{ field.name }}")
{%- endif %}
{%- elif field.data_type is ArrayType %}
    -- array type
{%-     if field.data_type is FixedLengthArrayType %}
    -- Fixed Length Array of {{field.data_type.capacity}} elements
{%-         if field.data_type.element_type is BooleanType %}
    -- bool mask!
    local mask = payload(offset, ({{field.data_type.capacity}} / 8)):bytes()
    local set_indexes = {}
    local functor = function(proto, byte_array, pinfo, tree, byte_offset, bit_index)
        table.insert(set_indexes, tostring(bit_index))
    end
    nunavut_support.as_bool_array(proto, mask, pinfo, subtree, functor, "{{field.name}}")
    local index_str = table.concat(set_indexes, ", ")
    subtree:add(proto, payload(offset, ({{field.data_type.capacity}} / 8)), string.format("[%s]", index_str))
    offset = offset + ({{field.data_type.capacity}} / 8)
{%-         elif field.data_type.element_type is PrimitiveType %}
    _length_ = {{field.data_type.capacity}}
    field_size = {{ field.data_type.element_type | to_serialized_length }}
    for i = 1, _length_ do
        -- element is primitive type {{ field.data_type.element_type }}
        tvb = payload(offset, field_size)
        value = tvb:le_{{ field.data_type.element_type | to_wireshark_type }}()
        subtree:add_le(proto, tvb, value, string.format("{{field.name}}[%u]", i))
        offset = offset + field_size
    end
{%-         else %}
    _length_ = {{field.data_type.capacity}}
    for i = 1, _length_ do
        -- composite type {{ field.data_type.element_type }}
        local data = payload(offset, {{ field.data_type.element_type | full_reference_name }}.extent)
        offset = offset + {{ field.data_type.element_type | full_reference_name}}.decode(proto, data, pinfo, subtree, string.format("{{field.name}}[%u]", i))
    end
{%-         endif %}
{%-     elif field.data_type is VariableLengthArrayType %}
    -- Variable Length Array has a length field of {{ field.data_type.length_field_type | to_serialized_length }} bytes
    _length_ = payload(offset, {{ field.data_type.length_field_type | to_serialized_length }}):le_uint()
    offset = offset + {{ field.data_type.length_field_type | to_serialized_length }}
{%-         if field.data_type.element_type is BooleanType %}
    -- bool mask!
    local mask = payload(offset, (_length_ / 8)):bytes()
    local set_indexes = {}
    local functor = function(proto, byte_array, pinfo, tree, byte_offset, bit_index)
        table.insert(set_indexes, tostring(bit_index))
    end
    nunavut_support.as_bool_array(proto, mask, pinfo, subtree, functor, "{{field.name}}")
    local index_str = table.concat(set_indexes, ", ")
    subtree:add(proto, payload(offset, (_length_ / 8)), string.format("[%s]", index_str))
    offset = offset + (_length_ / 8)
{%-         elif field.data_type.element_type is PrimitiveType %}
    field_size = {{ field.data_type.element_type | to_serialized_length }}
{%-             if field.data_type.element_type is UnsignedIntegerType and field.data_type.element_type.bit_length == 8 %}
    -- Special case: uint8 array might be an ASCII string
    if _length_ > 0 then
        local byte_data = payload(offset, _length_ * field_size):bytes()
        local is_ascii = true
        local has_printable = false
        -- Check if data is ASCII printable or whitespace
        for i = 0, _length_ - 1 do
            local byte_val = byte_data:get_index(i)
            if byte_val >= 32 and byte_val <= 126 then
                has_printable = true
            elseif byte_val ~= 9 and byte_val ~= 10 and byte_val ~= 13 and byte_val ~= 0 then
                -- Not printable, not tab, not newline, not carriage return, not null
                is_ascii = false
                break
            end
        end
        if is_ascii and has_printable then
            -- Display as ASCII string (use proto directly, not the typed ProtoField)
            local str_value = payload(offset, _length_ * field_size):string()
            subtree:add(proto, payload(offset - {{ field.data_type.length_field_type | to_serialized_length }}, _length_ * field_size + {{ field.data_type.length_field_type | to_serialized_length }}), string.format("{{field.name}}: \"%s\"", str_value))
        else
            -- Display as hex bytes
            for i = 1, _length_ do
                tvb = payload(offset + (i - 1) * field_size, field_size)
                value = tvb:le_uint()
                subtree:add_le(proto, tvb, value, string.format("{{field.name}}[%u]", i))
            end
        end
    end
    offset = offset + _length_ * field_size
{%-             else %}
    for i = 1, _length_ do
        -- element is primitive type {{ field.data_type.element_type }}
        tvb = payload(offset, field_size)
        value = tvb:le_{{ field.data_type.element_type | to_wireshark_type }}()
        subtree:add_le(proto, tvb, value, string.format("{{field.name}}[%u]", i))
        offset = offset + field_size
        {#
        offset = offset + nunavut_support.as_{{ field.data_type.element_type | to_protofield_type }}(
                {{ field.data_type.element_type | full_reference_name }}_{{ field.name }},
                payload(offset, {{ field.data_type.element_type | to_serialized_length }}),
                pinfo, subtree, "{{ field.name }}")
        #}
    end
{%-             endif %}
{%-         else %}
    for i = 1, _length_ do
        -- composite type {{ field.data_type.element_type }}
        local data = payload(offset, {{ field.data_type.element_type | full_reference_name }}.extent)
        offset = offset + {{ field.data_type.element_type | full_reference_name}}.decode(proto, data, pinfo, subtree, string.format("{{field.name}}[%u]", i))
    end
{%-         endif %}
{%-     else %}
    -- Unknown Array Type?
{%-     endif %}
{%- elif field.data_type is CompositeType %}
    -- composite type
{%-     if 'uavcan.primitive.String' in (field.data_type.full_name or '') %}
    -- Special handling for uavcan.primitive.String: display as UTF-8 string
    _length_ = payload(offset, 2):le_uint()  -- String uses 2-byte length prefix
    offset = offset + 2
    if _length_ > 0 then
        local str_value = payload(offset, _length_):string()
        subtree:add({{ type | full_reference_name }}.{{ field.name }}, payload(offset - 2, _length_ + 2), str_value)
    else
        subtree:add({{ type | full_reference_name }}.{{ field.name }}, payload(offset - 2, 2), "(empty)")
    end
    offset = offset + _length_
{%-     elif 'uavcan.primitive.Unstructured' in (field.data_type.full_name or '') %}
    -- Special handling for uavcan.primitive.Unstructured: display raw bytes without decoding
    _length_ = payload(offset, 2):le_uint()  -- Unstructured uses 2-byte length prefix
    offset = offset + 2
    if _length_ > 0 then
        subtree:add({{ type | full_reference_name }}.{{ field.name }}, payload(offset - 2, _length_ + 2), string.format("%d bytes", _length_))
    else
        subtree:add({{ type | full_reference_name }}.{{ field.name }}, payload(offset - 2, 2), "(empty)")
    end
    offset = offset + _length_
{%-     elif field.data_type is DelimitedType %}
    -- Delimited type: read length prefix first
    _delimiter_ = payload(offset, {{ field.data_type.delimiter_header_type | to_serialized_length }}):le_uint()
    offset = offset + {{ field.data_type.delimiter_header_type | to_serialized_length }}
    -- Use delimiter length for deserialization
    offset = offset + {{ field.data_type | full_reference_name }}.decode(
            proto, payload(offset, _delimiter_),
            pinfo, subtree, "{{field.name}}")
{%-     else %}
    -- Non-delimited composite: use full extent
    field_size = {{ field.data_type | full_reference_name }}.extent
    offset = offset + {{ field.data_type | full_reference_name }}.decode(
            proto, payload(offset, field_size),
            pinfo, subtree, "{{field.name}}")
{%-     endif %}
{%- else %}
    -- Unknown type {{field.name}} of type {{field.data_type}}
{%- endif %}
