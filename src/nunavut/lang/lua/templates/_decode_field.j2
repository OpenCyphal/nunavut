{#
type - the current Type
field - the ProtoField of the Type
offset - the current offset
_delimiter_ - if a delimiter is used, this will be set to the extent of the field.
field_size - used to store either the extent or the delimited size
payload - The tvb
pinfo - The packet info
subtree - The current level of the tree structure
#}
{%- if field.data_type is VoidType %}
    -- void type
    offset = offset + {{ field.data_type | to_serialized_length }}
{%- elif field.data_type is BooleanType %}
    -- boolean type
    offset = offset + nunavut_support.as_bool(
            {{ type | full_reference_name }}_{{ field.name }},
            payload, offset, subtree) -- , "{{ field.name }}")
{%- elif field.data_type is PrimitiveType %}
    -- primitive type {{ field.data_type }}
    offset = offset + nunavut_support.as_{{ field.data_type | to_protofield_type }}(
            {{ type | full_reference_name }}_{{ field.name }},
            payload, offset, {{ field.data_type | to_serialized_length }},
            subtree) -- , "{{ field.name }}")
{%- elif field.data_type is ArrayType %}
    -- array type
{%-     if field.data_type is FixedLengthArrayType %}
    -- Fixed Length Array of {{field.data_type.capacity}} elements
{%-         if field.data_type.element_type is BooleanType %}
    -- bool mask!
    local mask = payload(offset, ({{field.data_type.capacity}} / 8)):bytes()
    local functor = function(proto, byte_array, pinfo, tree, index)
        -- Create a big-endian bit string representation
        local bit_string = string.format("[%u]", index)
        subtree:add(proto, byte_array(0, ({{field.data_type.capacity}} / 8)), bit_string)
    end
    nunavut_support.as_bool_array(proto, mask, pinfo, subtree, functor, "{{field.name}}")
    offset = offset + ({{field.data_type.capacity}} / 8)
{%-         elif field.data_type.element_type is PrimitiveType %}
    _length_ = {{field.data_type.capacity}}
    field_size = {{ field.data_type.element_type | to_serialized_length }}
    for i = 1, _length_ do
        -- element is primitive type {{ field.data_type.element_type }}
        tvb = payload(offset, field_size)
        value = tvb:le_{{ field.data_type.element_type | to_wireshark_type }}()
        subtree:add_le(proto, tvb, value, string.format("{{field.name}}[%u]", i))
        offset = offset + field_size
    end
{%-         else %}
    _length_ = {{field.data_type.capacity}}
    for i = 1, _length_ do
        -- composite type {{ field.data_type.element_type }}
        local data = payload(offset, {{ field.data_type.element_type | full_reference_name }}.extent)
        offset = offset + {{ field.data_type.element_type | full_reference_name}}.decode(proto, data, pinfo, subtree, string.format("{{field.name}}[%u]", i))
    end
{%-         endif %}
{%-     elif field.data_type is VariableLengthArrayType %}
    -- Variable Length Array has a length field of {{ field.data_type.length_field_type | to_serialized_length }} bytes
    _length_ = payload(offset, {{ field.data_type.length_field_type | to_serialized_length }}):le_uint()
    offset = offset + {{ field.data_type.length_field_type | to_serialized_length }}
{%-         if field.data_type.element_type is BooleanType %}
    -- bool mask!
    local mask = payload(offset, (_length_ / 8)):bytes()
    local functor = function(proto, byte_array, pinfo, tree, index)
        -- Create a big-endian bit string representation
        local bit_string = string.format("[%u]", index)
        subtree:add(proto, byte_array(0, (_length_ / 8)), bit_string)
    end
    nunavut_support.as_bool_array(proto, mask, pinfo, subtree, functor, "{{field.name}}")
    offset = offset + (_length_ / 8)
{%-         elif field.data_type.element_type is PrimitiveType %}
    field_size = {{ field.data_type.element_type | to_serialized_length }}
    for i = 1, _length_ do
        -- element is primitive type {{ field.data_type.element_type }}
        tvb = payload(offset, field_size)
        value = tvb:le_{{ field.data_type.element_type | to_wireshark_type }}()
        subtree:add_le(proto, tvb, value, string.format("{{field.name}}[%u]", i))
        offset = offset + field_size
        {#
        offset = offset + nunavut_support.as_{{ field.data_type.element_type | to_protofield_type }}(
                {{ field.data_type.element_type | full_reference_name }}_{{ field.name }},
                payload(offset, {{ field.data_type.element_type | to_serialized_length }}),
                pinfo, subtree, "{{ field.name }}")
        #}
    end
{%-         else %}
    for i = 1, _length_ do
        -- composite type {{ field.data_type.element_type }}
        local data = payload(offset, {{ field.data_type.element_type | full_reference_name }}.extent)
        offset = offset + {{ field.data_type.element_type | full_reference_name}}.decode(proto, data, pinfo, subtree, string.format("{{field.name}}[%u]", i))
    end
{%-         endif %}
{%-     else %}
    -- Unknown Array Type?
{%-     endif %}
{%- elif field.data_type is CompositeType %}
    -- composite type
{%-     if 'uavcan.primitive.String' in (field.data_type.full_name or '') %}
    -- Special handling for uavcan.primitive.String: display as UTF-8 string
    _length_ = payload(offset, 2):le_uint()  -- String uses 2-byte length prefix
    offset = offset + 2
    if _length_ > 0 then
        local str_value = payload(offset, _length_):string()
        subtree:add({{ type | full_reference_name }}_{{ field.name }}, payload(offset - 2, _length_ + 2), str_value)
    else
        subtree:add({{ type | full_reference_name }}_{{ field.name }}, payload(offset - 2, 2), "(empty)")
    end
    offset = offset + _length_
{%-     elif 'uavcan.primitive.Unstructured' in (field.data_type.full_name or '') %}
    -- Special handling for uavcan.primitive.Unstructured: display raw bytes without decoding
    _length_ = payload(offset, 2):le_uint()  -- Unstructured uses 2-byte length prefix
    offset = offset + 2
    if _length_ > 0 then
        subtree:add({{ type | full_reference_name }}_{{ field.name }}, payload(offset - 2, _length_ + 2), string.format("%d bytes", _length_))
    else
        subtree:add({{ type | full_reference_name }}_{{ field.name }}, payload(offset - 2, 2), "(empty)")
    end
    offset = offset + _length_
{%-     elif field.data_type is DelimitedType %}
    -- Delimited type: read length prefix first
    _delimiter_ = payload(offset, {{ field.data_type.delimiter_header_type | to_serialized_length }}):le_uint()
    offset = offset + {{ field.data_type.delimiter_header_type | to_serialized_length }}
    -- Use delimiter length for deserialization
    offset = offset + {{ field.data_type | full_reference_name }}.decode(
            proto, payload(offset, _delimiter_),
            pinfo, subtree, "{{field.name}}")
{%-     else %}
    -- Non-delimited composite: use full extent
    field_size = {{ field.data_type | full_reference_name }}.extent
    offset = offset + {{ field.data_type | full_reference_name }}.decode(
            proto, payload(offset, field_size),
            pinfo, subtree, "{{field.name}}")
{%-     endif %}
{%- else %}
    -- Unknown type {{field.name}} of type {{field.data_type}}
{%- endif %}
