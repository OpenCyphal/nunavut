{#-
 # Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # Copyright (C) 2021  UAVCAN Development Team  <uavcan.org>
 # This software is distributed under the terms of the MIT License.
#}
// +-------------------------------------------------------------------------------------------------------------------+
// | EXPLICIT TEMPLATE SPECIALIZATION
// +-------------------------------------------------------------------------------------------------------------------+
{%- for field in composite_type.fields_except_padding %}
template<>
constexpr typename {{ composite_type | short_reference_name }}::VariantType::alternative<{{ loop.index0 }}>::type* {{ composite_type | short_reference_name }}::VariantType::get_if<
        {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }}
    >({{ composite_type | short_reference_name }}::VariantType* v) noexcept
{
    {{ field.data_type | declaration }}* result = nullptr;
    if (v)
    {
        {{ composite_type | short_reference_name }}::VariantType& vref = *v;
        if(vref.tag_ == {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }})
        {
            static_assert(std::is_same<typename {{ composite_type | short_reference_name }}::VariantType::alternative<{{ loop.index0 }}>::type, {{ field.data_type | declaration }}>::value,
                          "The alternative type determined by the compiler disagrees with the generated type.");
            result = reinterpret_cast<{{ field.data_type | declaration }}*>(&vref.internal_union_value_.{{ field.name | id }});
        }
    }

    return result;
}

template<>
constexpr const typename {{ composite_type | short_reference_name }}::VariantType::alternative<{{ loop.index0 }}>::type* {{ composite_type | short_reference_name }}::VariantType::get_if<
         {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }}
    >(const {{ composite_type | short_reference_name }}::VariantType* v) noexcept
{
    const {{ field.data_type | declaration }}* result = nullptr;
    if (v)
    {
        const {{ composite_type | short_reference_name }}::VariantType& vref = *v;
        if(vref.tag_ == {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }})
        {
            static_assert(std::is_same<typename {{ composite_type | short_reference_name }}::VariantType::alternative<{{ loop.index0 }}>::type, {{ field.data_type | declaration }}>::value,
                          "The alternative type determined by the compiler disagrees with the generated type.");
            result = reinterpret_cast<const {{ field.data_type | declaration }}*>(&vref.internal_union_value_.{{ field.name | id }});
        }
    }

    return result;
}

template<>
{{ field.data_type | declaration }}& {{ composite_type | short_reference_name }}::VariantType::emplace<
        {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }}
    >({{ field.data_type | declaration }}&& v)
{
    destroy_current();
    {{ field.data_type | declaration }}* result = new (&internal_union_value_.{{ field.name | id }}) {{ field.data_type | declaration }}(std::forward<{{ field.data_type | declaration }}>(v));
    tag_ = {{ composite_type | short_reference_name }}::VariantType::IndexOf::{{ field.name | id }};
    return *result;
}
{% endfor-%}
