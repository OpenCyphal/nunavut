{#-
 # Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # Copyright (C) 2022  UAVCAN Development Team  <uavcan.org>
 # This software is distributed under the terms of the MIT License.
 # Authors: David Lenfesty, Scott Dixon <dixonsco@amazon.com>, Pavel Kirienko <pavel@uavcan.org>,
 #          Peter van der Perk <peter.vanderperk@nxp.com>, Pavel Pletenev <cpp.create@gmail.com>
-#}

{% from '_definitions.j2' import assert, LITTLE_ENDIAN %}

{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro serialize(t) %}
{% if t.inner_type.bit_length_set.max > 0 %}
    {{ _serialize_impl(t) }}
{% else %}
    (void)(out_buffer);
    return 0U;
{% endif %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_impl(t) %}

    const {{ typename_unsigned_length }} capacity_bits = out_buffer.size();

{%- if options.enable_override_variable_array_capacity %}
#ifndef {{ t | full_reference_name }}_DISABLE_SERIALIZATION_BUFFER_CHECK_
{% endif %}
    if ((static_cast<{{ typename_unsigned_bit_length }}>(capacity_bits)) < {{ t.inner_type.bit_length_set.max }}UL)
    {
        return -nunavut::support::Error::SERIALIZATION_BUFFER_TOO_SMALL;
    }
{%- if options.enable_override_variable_array_capacity %}
#endif
{% endif %}

    // Notice that fields that are not an integer number of bytes long may overrun the space allocated for them
    // in the serialization buffer up to the next byte boundary. This is by design and is guaranteed to be safe.
    {{ assert('out_buffer.offset_alings_to_byte()') }}
{% if t.inner_type is StructureType %}
    {%- for f, offset in t.inner_type.iterate_fields_with_offsets() %}
        {%- if loop.first %}
            {%- assert f.data_type.alignment_requirement <= t.inner_type.alignment_requirement %}
        {%- else %}
    {{ _pad_to_alignment(f.data_type.alignment_requirement)|trim|remove_blank_lines }}
        {%- endif %}
    {   // {{ f }}
        {{ _serialize_any(f.data_type, (f|id), offset)|trim|remove_blank_lines|indent }}
    }
    {%- endfor %}
{% elif t.inner_type is UnionType %}
{#
    {   // Union tag field: {{ t.inner_type.tag_field_type }}
        {{
            _serialize_integer(t.inner_type.tag_field_type, 'obj->_tag_', 0|bit_length_set)
           |trim|remove_blank_lines|indent
        }}
    }
    {% for f, offset in t.inner_type.iterate_fields_with_offsets() %}
    {{ 'if' if loop.first else 'else if' }} ({{ loop.index0 }}U == obj->_tag_)  // {{ f }}
    {
        {%- assert f.data_type.alignment_requirement <= (offset.min) %}
        {{ _serialize_any(f.data_type, (f|id), offset)|trim|remove_blank_lines|indent }}
    }
    {%- endfor %}
    else
#}
    {
        return -nunavut::support::Error::REPRESENTATION_BAD_UNION_TAG;
    }
{% else %}{% assert False %}
{% endif %}

    {{ _pad_to_alignment(t.inner_type.alignment_requirement)|trim|remove_blank_lines }}
    // It is assumed that we know the exact type of the serialized entity, hence we expect the size to match.
{% if not t.inner_type.bit_length_set.fixed_length %}
    {{ assert('out_buffer.offset() >= %sULL'|format(t.inner_type.bit_length_set.min)) }}
    {{ assert('out_buffer.offset() <= %sULL'|format(t.inner_type.bit_length_set.max)) }}
{% else %}
    {{ assert('out_buffer.offset() == %sULL'|format(t.inner_type.bit_length_set.max)) }}
{% endif %}
    {{ assert('out_buffer.offset_alings_to_byte()') }}
    return out_buffer.offset_bytes_ceil();

{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _pad_to_alignment(n_bits) %}
{% if n_bits > 1 %}
    {
        {% set ref_result = 'result'|to_template_unique_name %}
        const auto {{ref_result}} = out_buffer.padAndMoveToAlignment({{ n_bits }}U);
        if(not {{ref_result}}){
            return -{{ref_result}}.error();
        }
    }
{% endif %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_any(t, reference, offset) %}
{% if t.alignment_requirement > 1 %}
    {{ assert('out_buffer.offset_alings_to(%dU)'|format(t.alignment_requirement)) }}
{% endif %}
{% if offset.is_aligned_at_byte() %}
    {{ assert('out_buffer.offset_alings_to_byte()') }}
{% endif %}
    {# NOTICE: If this is a delimited type, we will be requiring the buffer to be at least extent-sized.
     # This is a bit wasteful because when serializing we can often use a smaller buffer. #}
    {% if t.bit_length_set.max > 0 %}
    {{ assert('%dULL <= out_buffer.size()'|format(t.bit_length_set.max)) }}
    {% endif %}

{%   if t is VoidType %}                {{- _serialize_void(t, offset) }}
{% elif t is BooleanType %}             {{- _serialize_boolean(t, reference, offset) }}
{% elif t is IntegerType %}             {{- _serialize_integer(t, reference, offset) }}
{% elif t is FloatType %}               {{- _serialize_float(t, reference, offset) }}
{% elif t is FixedLengthArrayType %}    {{- _serialize_fixed_length_array(t, reference, offset) }}
{% elif t is VariableLengthArrayType %} {{- _serialize_variable_length_array(t, reference, offset) }}
{% elif t is CompositeType %}           {{- _serialize_composite(t, reference, offset) }}
{% else %}{#{% assert False %}#}
{% endif %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_void(t, offset) %}
    {% set ref_result = 'result'|to_template_unique_name %}
    auto {{ ref_result }} = out_buffer.setZeros({{ t.bit_length }}UL);
    if(not {{ ref_result }}){
        return -{{ ref_result }}.error();
    }
    out_buffer.add_offset({{ t.bit_length }}UL);
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_boolean(t, reference, offset) %}
    {% set ref_result = 'result'|to_template_unique_name %}
    auto {{ ref_result }} = out_buffer.setBit({{ reference }});
    if(not {{ ref_result }}){
        return -{{ ref_result }}.error();
    }
    out_buffer.add_offset(1UL);
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_integer(t, reference, offset) %}
{% if t is saturated %}
    {% if not t.standard_bit_length %}
        {% set ref_value = 'sat'|to_template_unique_name %}
    {{ t|type_from_primitive }} {{ ref_value }} = {{ reference }};
        {% if t is UnsignedIntegerType %}
            {% assert t.inclusive_value_range[0] == 0 %}
        {% else %}
    if ({{ ref_value }} < {{ t.inclusive_value_range[0]|literal(t) }})
    {
        {{ ref_value }} = {{ t.inclusive_value_range[0]|literal(t) }};
    }
        {% endif %}
    if ({{ ref_value }} > {{ t.inclusive_value_range[1]|literal(t) }})
    {
        {{ ref_value }} = {{ t.inclusive_value_range[1]|literal(t) }};
    }
    {% else %}
        {% set ref_value = reference %}
    // Saturation code not emitted -- native representation matches the serialized representation.
    {% endif %}
{% else %}
    {% set ref_value = reference %}
{% endif %}
    {% set ref_result = 'result'|to_template_unique_name %}
    const auto {{ref_result}} = out_buffer.set{{ 'U' if t is UnsignedIntegerType else 'I' }}xx({#- -#}
        {{ ref_value }}, {{ t.bit_length }}U);
    if(not {{ref_result}}){
        return -{{ref_result}}.error();
    }
    out_buffer.add_offset({{ t.bit_length }}U);
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_float(t, reference, offset) %}
{% if t is saturated %}
    {% if t.bit_length not in (32, 64) %}
        {% set ref_value = 'sat'|to_template_unique_name %}
    {{ t|type_from_primitive }} {{ ref_value }} = {{ reference }};
    if (std::isfinite({{ ref_value }}))
    {
        if ({{ ref_value }} < {{ t.inclusive_value_range[0]|literal(t) }})
        {
            {{ ref_value }} = {{ t.inclusive_value_range[0]|literal(t) }};
        }
        if ({{ ref_value }} > {{ t.inclusive_value_range[1]|literal(t) }})
        {
            {{ ref_value }} = {{ t.inclusive_value_range[1]|literal(t) }};
        }
    }
    {% elif t.bit_length == 32 %}
        {% set ref_value = reference %}
    // Saturation code not emitted -- assume the native representation of float32 is conformant.
    static_assert(NUNAVUT_PLATFORM_IEEE754_FLOAT, "Native IEEE754 binary32 required. TODO: relax constraint");
    {% elif t.bit_length == 64 %}
        {% set ref_value = reference %}
    // Saturation code not emitted -- assume the native representation of float64 is conformant.
    static_assert(NUNAVUT_PLATFORM_IEEE754_DOUBLE, "Native IEEE754 binary64 required. TODO: relax constraint");
    {% else %}{% assert False %}
    {% endif %}
{% else %}
    {% set ref_value = reference %}
{% endif %}
    {% set ref_result = 'result'|to_template_unique_name %}
    auto {{ ref_result }} = out_buffer.setF{{ t.bit_length }}({{ ref_value }});
    if(not {{ ref_result }}){
        return -{{ ref_result }}.error();
    }
    out_buffer.add_offset({{ t.bit_length }}U);
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_fixed_length_array(t, reference, offset) %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_variable_length_array(t, reference, offset) %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _serialize_composite(t, reference, offset) %}
{% endmacro %}
