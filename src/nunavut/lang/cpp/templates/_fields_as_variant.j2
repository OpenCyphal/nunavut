{#-
 # Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # Copyright (C) 2021  OpenCyphal Development Team  <opencyphal.org>
 # This software is distributed under the terms of the MIT License.
#}
    class VariantType final : public std::variant<
{%- for field in composite_type.fields_except_padding %}
        {{ field.doc | block_comment('cpp-doxygen', 8, 120) }}
        _traits_::TypeOf::{{field.name|id}}{% if not loop.last %},{% endif %}
{%- endfor %}
    >
    {
    public:

        using Base = std::variant<
{%- for field in composite_type.fields_except_padding %}
            _traits_::TypeOf::{{field.name|id}}{% if not loop.last %},{% endif %}
{%- endfor %}
        >;

        static const constexpr std::size_t variant_npos = std::variant_npos;

        struct IndexOf final
        {
            IndexOf() = delete;
{%- for field in composite_type.fields_except_padding %}
            static constexpr const std::size_t {{ field.name | id }} = {{ loop.index0 }}U;
{%- endfor %}
        };

        static constexpr const std::size_t MAX_INDEX = {{ composite_type.fields_except_padding  | length }}U;

        template<std::size_t I>
        using is_index = std::conditional_t<(I < MAX_INDEX), std::true_type, std::false_type>;

        template<std::size_t I>
        static constexpr const bool is_index_v = is_index<I>::value;

        template<size_t I, typename T>
        struct alternative;

        template<size_t I, typename... Types>
        struct alternative<I, std::variant<Types...>> final
        {
            using type = typename std::variant_alternative<I, std::variant<Types...>>::type;
        };

        template<size_t I, typename T>
        struct alternative<I, const T> final
        {
            using type = std::add_const_t<typename std::variant_alternative<I, T>::type>;
        };

        // Default constructor
        VariantType() = default;

        // Initializing constructor
        template<std::size_t I, typename... Args, typename = std::enable_if_t<is_index_v<I>>>
        VariantType(nunavut::support::in_place_index_t<I> i, Args&&... args) :
            Base{std::in_place_index_t<I>{}, std::forward<Args>(args)...}
        {
            (void)i; // avoid unused param warning
        }

        // Copy constructor
        VariantType(const VariantType& rhs) :
            Base{rhs}
        {}

        // Move constructor
        VariantType(VariantType&& rhs) :
            Base{std::move(rhs)}
        {}

        // Copy assignment
        VariantType& operator=(const VariantType& rhs)
        {
            (void)Base::operator=(rhs); // avoid unused return value warning
            return *this;
        }

        // Move assignment
        VariantType& operator=(VariantType&& rhs)
        {
            (void)Base::operator=(std::move(rhs)); // avoid unused return value warning
            return *this;
        }

        // Destructor
        ~VariantType() = default;

        template<std::size_t I, class... Types>
        static constexpr typename alternative<I, std::variant<Types...>>::type* get_if(std::variant<Types...>* v) noexcept
        {
            return std::get_if<I, Types...>(v);
        }

        template<std::size_t I, class... Types>
        static constexpr const typename alternative<I, std::variant<Types...>>::type* get_if(const std::variant<Types...>* v) noexcept
        {
            return std::get_if<I, Types...>(v);
        }

    };
