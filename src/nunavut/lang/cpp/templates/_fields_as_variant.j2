{#-
 # Copyright 2021 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # Copyright (C) 2021  UAVCAN Development Team  <uavcan.org>
 # This software is distributed under the terms of the MIT License.
#}
    using VariantType = class VariantType_ final : public std::variant<
{%- for field in composite_type.fields_except_padding %}
        {{ field.doc | block_comment('cpp-doxygen', 8, 120) }}
        {{ field.data_type | declaration }}{% if not loop.last %},{% endif %}
{%- endfor %}
    >
    {
    public:

        template< class T>
        static constexpr const T* get_if(const {{ composite_type | short_reference_name }}::VariantType_* v) noexcept
        {
            return std::get_if<T>(v);
        }

        template< class T>
        static constexpr T* get_if({{ composite_type | short_reference_name }}::VariantType_* v) noexcept
        {
            return std::get_if<T>(v);
        }

        template< class T >
        static constexpr bool holds_alternative( const {{ composite_type | short_reference_name }}::VariantType_& v ) noexcept
        {
            return std::holds_alternative<T>(v);
        }
    };

    VariantType union_value;
