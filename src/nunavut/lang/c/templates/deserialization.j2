{#-
 # Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 # Copyright (C) 2020  UAVCAN Development Team  <uavcan.org>
 # This software is distributed under the terms of the MIT License.
 # Authors: David Lenfesty, Scott Dixon <dixonsco@amazon.com>, Pavel Kirienko <pavel@uavcan.org>,
 #          Peter van der Perk <peter.vanderperk@nxp.com>
-#}

{% from 'definitions.j2' import assert, LITTLE_ENDIAN %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro deserialize(t) %}
    if ((out_obj == {{ valuetoken_null }}) || (buffer == {{ valuetoken_null }}) || {# -#}
        (inout_buffer_size_bytes == {{ valuetoken_null }}))
    {
        return -NUNAVUT_ERROR_INVALID_ARGUMENT;
    }
{% if t.inner_type.bit_length_set|max > 0 %}
    {{ _deserialize_impl(t) }}
{% else %}
    *inout_buffer_size_bytes = 0U;
{% endif %}
    return NUNAVUT_SUCCESS;
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_impl(t) %}
    const {{ typename_unsigned_length }} capacity_bytes = *inout_buffer_size_bytes;
    const {{ typename_unsigned_bit_length }} capacity_bits = capacity_bytes * ({{ typename_unsigned_bit_length }}) 8U;
    {{ typename_unsigned_bit_length }} offset_bits = 0U;
{% if t.inner_type is StructureType %}
    {% for f, offset in t.inner_type.iterate_fields_with_offsets(0) %}
        {% if loop.first %}
            {% assert f.data_type.alignment_requirement <= t.inner_type.alignment_requirement %}
        {% else %}
    {{ _pad_to_alignment(f.data_type.alignment_requirement) }}
        {% endif %}
    // {{ f }}
    {{ _deserialize_any(f.data_type, 'out_obj->' + (f|id), offset)|trim|remove_blank_lines }}
    {% endfor %}
{% elif t.inner_type is UnionType %}
    // TODO: union deserialization.
    {{ assert('false') }}
{% else %}{% assert False %}
{% endif %}
    {{ _pad_to_alignment(t.inner_type.alignment_requirement) }}
    {{ assert('offset_bits <= %sULL'|format(t.inner_type.bit_length_set|max)) }}
    {{ assert('offset_bits % 8U == 0U') }}
    *inout_buffer_size_bytes = {# -#}
        (offset_bits < capacity_bits) ? ({{ typename_unsigned_length }}) (offset_bits / 8U) : capacity_bytes;
    {{ assert('capacity_bytes >= *inout_buffer_size_bytes') }}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _pad_to_alignment(n_bits) %}
{%- if n_bits > 1 -%}
    {%- assert n_bits in (8, 16, 32, 64) -%}
    offset_bits = (offset_bits + {{ n_bits - 1 }}U) & ~(({{ typename_unsigned_bit_length }}) {{ n_bits - 1 }}U);  {# -#}
        // Align on {{ n_bits }} bits.
{%- endif -%}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_any(t, reference, offset) %}
{% if t.alignment_requirement > 1 %}
    {{ assert('offset_bits %% %dU == 0U'|format(t.alignment_requirement)) }}
{% endif %}
{% if offset.is_aligned_at_byte() %}
    {{ assert('offset_bits % 8U == 0U') }}
{% endif %}
{%   if t is VoidType %}                {{- _deserialize_void                 (t,            offset) }}
{% elif t is BooleanType %}             {{- _deserialize_boolean              (t, reference, offset) }}
{% elif t is IntegerType %}             {{- _deserialize_integer              (t, reference, offset) }}
{% elif t is FloatType %}               {{- _deserialize_float                (t, reference, offset) }}
{% elif t is FixedLengthArrayType %}    {{- _deserialize_fixed_length_array   (t, reference, offset) }}
{% elif t is VariableLengthArrayType %} {{- _deserialize_variable_length_array(t, reference, offset) }}
{% elif t is CompositeType %}           {{- _deserialize_composite            (t, reference, offset) }}
{% else %}{% assert False %}
{% endif %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_void(t, offset) %}
    offset_bits += {{ t.bit_length }};
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_boolean(t, reference, offset) %}
    if (offset_bits < capacity_bits)
    {
{% if offset.is_aligned_at_byte() %}
        {{ reference }} = (buffer[offset_bits / 8U] & 1U) != 0U;
{% else %}
        {{ reference }} = (buffer[offset_bits / 8U] & (1U << (offset_bits % 8U))) != 0U;
{% endif %}
    }
    else
    {
        {{ reference }} = {{ valuetoken_false }};
    }
    offset_bits += 1U;
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_integer(t, reference, offset) %}
{% set getter = 'nunavutGet%s%d'|format('U' if t is UnsignedIntegerType else 'I', t|to_standard_bit_length) %}
{# Mem-copy optimization is difficult to perform on non-standard-size signed integers because the C standard does
 # not define a portable way of unsigned-to-signed conversion (but the other way around is well-defined).
 # See 6.3.1.8 Usual arithmetic conversions, 6.3.1.3 Signed and unsigned integers.
 # This template can be greatly expanded with additional special cases if needed.
 #}
{% if offset.is_aligned_at_byte() and t is UnsignedIntegerType and t.bit_length <= 8 %}
    if ((offset_bits + {{ t.bit_length }}U) <= capacity_bits)
    {
        {{ reference }} = buffer[offset_bits / 8U] & {{ 2 ** t.bit_length - 1 }}U;
    }
    else
    {
        {{ reference }} = 0U;
    }
{% else %}
    {{ reference }} = {{ getter }}(&buffer[0], capacity_bytes, offset_bits, {{ t.bit_length }});
{% endif %}
    offset_bits += {{ t.bit_length }}U;
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_float(t, reference, offset) %}
    {# TODO: apply special case optimizations for aligned data and little-endian IEEE754-conformant platforms. #}
    {{ reference }} = nunavutGetF{{ t.bit_length }}(&buffer[0], capacity_bytes, offset_bits);
    offset_bits += {{ t.bit_length }}U;
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_fixed_length_array(t, reference, offset) %}
{# SPECIAL CASE: PACKED BIT ARRAY #}
{% if t.element_type is BooleanType %}
    nunavutGetBits(&{{ reference }}_bitpacked_[0], &buffer[0], capacity_bytes, offset_bits, {{ t.capacity }}UL);
    offset_bits += {{ t.capacity }}UL;

{# SPECIAL CASE: BYTES-LIKE ARRAY #}
{% elif t.element_type is PrimitiveType and t.element_type.bit_length == 8 and t.element_type|is_zero_cost_primitive %}
    nunavutGetBits(&{{ reference }}[0], &buffer[0], capacity_bytes, offset_bits, {{ t.capacity }}UL * 8U);
    offset_bits += {{ t.capacity }}UL * 8U;

{# SPECIAL CASE: ZERO-COST PRIMITIVES #}
{% elif t.element_type is PrimitiveType and LITTLE_ENDIAN and t.element_type|is_zero_cost_primitive %}
    {% if t.element_type is FloatType %}
    static_assert(NUNAVUT_PLATFORM_IEEE754_FLOAT, "Native IEEE754 binary32 required. TODO: relax constraint");
        {% if t.element_type.bit_length > 32 %}
    static_assert(NUNAVUT_PLATFORM_IEEE754_DOUBLE, "Native IEEE754 binary64 required. TODO: relax constraint");
        {% endif %}
    {% endif %}
    nunavutGetBits(&{{ reference }}[0], &buffer[0], capacity_bytes, offset_bits, {# -#}
                   {{ t.capacity }}UL * {{ t.element_type.bit_length }}U);
    offset_bits += {{ t.capacity }}UL * {{ t.element_type.bit_length }}U;

{# GENERAL CASE #}
{% else %}
    {% for index, element_offset in t.enumerate_elements_with_offsets(offset) %}
    // Array element #{{ index }}
    {{ _deserialize_any(t.element_type, reference + ('[%d]'|format(index)), element_offset)|trim }}
    {% endfor %}
{% endif %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_variable_length_array(t, reference, offset) %}
{% endmacro %}


{# ----------------------------------------------------------------------------------------------------------------- #}
{% macro _deserialize_composite(t, reference, offset) %}
{% endmacro %}
