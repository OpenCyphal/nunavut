{%- macro choose_min(a, b) -%}
    ((({{a}}) < ({{b}})) ? ({{a}}) : ({{b}}))
{%- endmacro -%}
{%- macro assert(expression) -%}
    {%- if option_enable_serialization_asserts -%}
    NUNAVUT_ASSERT({{ expression }});
    {%- endif -%}
{%- endmacro -%}
{%- macro float32_union() -%}
    typedef union  // NOSONAR
    {
        uint32_t bits;
        {{typename_float_32}} real;
    } Float32Bits;
{%- endmacro -%}
/*
 *  UAVCAN common serialization support routines.                                                             +-+ +-+
 *  This file is based on canard_dsdl.h, which is part of Libcanard.                                          | | | |
 *                                                                                                            \  -  /
 *  AUTOGENERATED, DO NOT EDIT.                                                                                 ---
 *                                                                                                               o
 * +------------------------------------------------------------------------------------------------------------------+
 */
#ifndef NUNAVUT_SUPPORT_SERIALIZATION_H_INCLUDED
#define NUNAVUT_SUPPORT_SERIALIZATION_H_INCLUDED

#ifdef __cplusplus
#   if (__cplusplus < 201100L)
#       error "Unsupported language: ISO C11, C++11, or a newer version of either is required."
#   endif
extern "C"
{
#else
#   if !defined(__STDC_VERSION__) || (__STDC_VERSION__ < 201112L)
#       error "Unsupported language: ISO C11 or a newer version is required."
#   endif
#endif

#include <string.h>
{%- if not option_omit_float_serialization_support %}
#include <float.h>
{% endif -%}
#include <stdbool.h>
#include <stdint.h>
#include <assert.h> // For static_assert (C11) and assert() if NUNAVUT_ASSERT is used.

static_assert(sizeof({{ typename_unsigned_bit_length }}) >= sizeof({{ typename_unsigned_length }}),
    "The bit-length type used by Nunavut, {{ typename_unsigned_bit_length }}, "
    "is smaller than this platform's {{ typename_unsigned_length }} type. "
    "Nunavut serialization relies on {{ typename_unsigned_length }} to {{ typename_unsigned_bit_length }} conversions "
    "that do not lose data. You will need to regenerate Nunavut serialization support with a larger "
    "unsigned_bit_length type specified.");

/// Nunavut returns 0 for success and < 0 for any failure. It is always adequate to
/// check that error_value < 0 to detect errors or error_value == 0 for success.
///
/// Nunavut serialization will never define more than 127 errors and the reserved
/// error numbers are [-1,-127] (-128 is not used).
///
/// Return values > 0 for Nunavut serialization are undefined.
#define NUNAVUT_SUCCESS 0
#define NUNAVUT_ERR_INVALID_BUF 1   /// Indicates a NULL pointer to a data buffer was given.
#define NUNAVUT_ERR_INVALID_LEN 2   /// Indicates a variable length array was serialized with an invalid length tag.
#define NUNAVUT_ERR_BUF_OVERFLOW 3  /// Indicates the data being deserialized overflows the given buffer.
#define NUNAVUT_ERR_INVALID_TAG 4   /// Indicates that a union field was assigned an invalid tag.

{% if not option_omit_float_serialization_support -%}
/// Detect whether the target platform is compatible with IEEE 754.
#define NUNAVUT_PLATFORM_IEEE754_FLOAT \
    ((FLT_RADIX == 2) && (FLT_MANT_DIG == 24) && (FLT_MIN_EXP == -125) && (FLT_MAX_EXP == 128))
#define NUNAVUT_PLATFORM_IEEE754_DOUBLE \
    ((FLT_RADIX == 2) && (DBL_MANT_DIG == 53) && (DBL_MIN_EXP == -1021) && (DBL_MAX_EXP == 1024))
{% endif -%}

{%- if option_enable_serialization_asserts %}
#ifndef NUNAVUT_ASSERT
// By default Nunavut does not generate assert statements since the logic to halt a program is platform
// dependent and because this header requires an absolute minimum from a platform and from the C standard library.
// Most platforms can simply define "NUNAVUT_ASSERT(x)=assert(x)" (<assert.h> is always included by Nunavut).
#   error "You must either define NUNAVUT_ASSERT or you need to disable assertions" \
          " when generating serialization support code using Nunavut language options"
#endif
{% endif -%}

{%- if option_target_endianness == 'little' %}
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && (__BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__)
#   error "This code has been generated for little-endian platforms only. " \
          "To generate portable endianness-invariant code, set the Nunavut option target_endianness='any' " \
          "and regenerate the code. This change will have some performance impact for little-endian machines."
#endif
{%- elif option_target_endianness in ('any', 'big') %}
// This code is endianness-invariant. Use target_endianness='little' to generate little-endian-optimized code.
{%- else %}{%- assert False %}
{%- endif %}

// --------------------------------------------- PRIMITIVE SERIALIZATION ---------------------------------------------

/// Calculate the number of bits to safely copy from serialized buffer.
/// Returns the smallest bit length based on requested parameters and available space.
static inline {{ typename_unsigned_bit_length }} _nunavutInternalGetBitCopySize(
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} offset_bit,
    const {{ typename_unsigned_bit_length }} requested_length_bit,
    const uint8_t value_length_bit)
{
    const {{ typename_unsigned_bit_length }} buf_size_bit  = ({{ typename_unsigned_bit_length }})buf_size_bytes * 8U;
    const {{ typename_unsigned_bit_length }} remaining_bit = {# -#}
        buf_size_bit - {{ choose_min('buf_size_bit', 'offset_bit') }};
    const {{ typename_unsigned_bit_length }} min_length_bit = {# -#}
        {{ choose_min('requested_length_bit', 'value_length_bit') }};
    const {{ typename_unsigned_bit_length }} min_remaining_length = {{ choose_min('remaining_bit', 'min_length_bit') }};
    return min_remaining_length;
}

// --------------------------------------------- PUBLIC API - BIT ARRAY ---------------------------------------------

static inline void nunavutCopyBits(
    const {{ typename_unsigned_bit_length }} length_bit,
    const {{ typename_unsigned_bit_length }} src_offset_bit,
    const {{ typename_unsigned_bit_length }} dst_offset_bit,
    const uint8_t* const src,
    uint8_t* const dst)
{
    // The algorithm was originally designed by Ben Dyer for Libuavcan v0:
    // https://github.com/UAVCAN/libuavcan/blob/legacy-v0/libuavcan/src/marshal/uc_bit_array_copy.cpp
    // This version is modified for v1 where the bit order is the opposite.
    {{ assert('src != NULL') }}
    {{ assert('dst != NULL') }}
    {{ assert('src != dst') }}
    if ((0U == (length_bit % 8U)) && (0U == (src_offset_bit % 8U)) && (0U == (dst_offset_bit % 8U)))
    {
        {{ assert('((src < dst) ? ((uintptr_t)(src + ((src_offset_bit + length_bit) / 8U)) <= (uintptr_t)dst) : 1)') }}
        {{ assert('((src > dst) ? ((uintptr_t)(dst + ((dst_offset_bit + length_bit) / 8U)) <= (uintptr_t)src) : 1)') }}
        // Intentional violation of MISRA: Pointer arithmetics. This is done to remove the API constraint that
        // offsets be under 8 bits. Fewer constraints reduce the chance of API misuse.
        (void) memcpy(dst + (dst_offset_bit / 8U), src + (src_offset_bit / 8U), length_bit / 8U);  // NOSONAR NOLINT
    }
    else
    {
        {{ typename_unsigned_bit_length }}       src_off  = src_offset_bit;
        {{ typename_unsigned_bit_length }}       dst_off  = dst_offset_bit;
        const {{ typename_unsigned_bit_length }} last_bit = src_off + length_bit;
        {{ assert(
            '((src < dst) ? ((uintptr_t)(src + ((src_offset_bit + length_bit + 8U) / 8U)) <= (uintptr_t)dst) : 1)'
        ) }}
        {{ assert(
            '((src > dst) ? ((uintptr_t)(dst + ((dst_offset_bit + length_bit + 8U) / 8U)) <= (uintptr_t)src) : 1)'
        ) }}
        while (last_bit > src_off)
        {
            const uint8_t src_mod = (uint8_t)(src_off % 8U);
            const uint8_t dst_mod = (uint8_t)(dst_off % 8U);
            const uint8_t max_mod = (src_mod > dst_mod) ? src_mod : dst_mod;
            const uint8_t size = (uint8_t) {{ choose_min('8U - max_mod', 'last_bit - src_off') }};
            {{ assert('size > 0U') }}
            {{ assert('size <= 8U') }}
            // Suppress a false warning from Clang-Tidy & Sonar that size is being over-shifted. It's not.
            const uint8_t mask = (uint8_t)((((1U << size) - 1U) << dst_mod) & 0xFFU);  // NOLINT NOSONAR
            {{ assert('mask > 0U') }}
            // Intentional violation of MISRA: indexing on a pointer.
            // This simplifies the implementation greatly and avoids pointer arithmetics.
            const uint8_t in = (uint8_t)((uint8_t)(src[src_off / 8U] >> src_mod) << dst_mod) & 0xFFU;  // NOSONAR
            // Intentional violation of MISRA: indexing on a pointer.
            // This simplifies the implementation greatly and avoids pointer arithmetics.
            const uint8_t a = dst[dst_off / 8U] & ((uint8_t) ~mask);  // NOSONAR
            const uint8_t b = in & mask;
            // Intentional violation of MISRA: indexing on a pointer.
            // This simplifies the implementation greatly and avoids pointer arithmetics.
            dst[dst_off / 8U] = a | b;  // NOSONAR
            src_off += size;
            dst_off += size;
        }
        {{ assert('last_bit == src_off') }}
    }
}

// --------------------------------------------- PUBLIC API - INTEGER ---------------------------------------------

static inline {{typename_error_type}} nunavutSetBit(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const bool value)
{
    {{ assert('buf != NULL') }}
    if ((buf_size_bytes * 8) <= off_bit)
    {
        return -NUNAVUT_ERR_BUF_OVERFLOW;
    }
    const uint8_t val = value ? 1U : 0U;
    nunavutCopyBits(1U, 0U, off_bit, &val, buf);
    return NUNAVUT_SUCCESS;
}

static inline {{typename_error_type}} nunavutSetUxx(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const uint64_t value,
    const uint8_t len_bit)
{
    static_assert(64U == (sizeof(uint64_t) * 8U), "Unexpected size of uint64_t");
    {{ assert('buf != NULL') }}
    if ((buf_size_bytes * 8) < (off_bit + len_bit))
    {
        return -NUNAVUT_ERR_BUF_OVERFLOW;
    }
    const {{ typename_unsigned_bit_length }} saturated_len_bit = {{ choose_min('len_bit', '64U') }};
{%- if option_target_endianness == 'little' %}
    nunavutCopyBits(saturated_len_bit, 0U, off_bit, (const uint8_t*) &value, buf);
{%- elif option_target_endianness in ('any', 'big') %}
    const uint8_t tmp[sizeof(uint64_t)] = {
        (uint8_t)((value >> 0U) & 0xFFU),
        (uint8_t)((value >> 8U) & 0xFFU),
        (uint8_t)((value >> 16U) & 0xFFU),
        (uint8_t)((value >> 24U) & 0xFFU),
        (uint8_t)((value >> 32U) & 0xFFU),
        (uint8_t)((value >> 40U) & 0xFFU),
        (uint8_t)((value >> 48U) & 0xFFU),
        (uint8_t)((value >> 56U) & 0xFFU),
    };
    nunavutCopyBits(saturated_len_bit, 0U, off_bit, &tmp[0], buf);
{%- else %}{%- assert False %}
{%- endif %}
    return NUNAVUT_SUCCESS;
}

static inline {{typename_error_type}} nunavutSetIxx(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const int64_t value,
    const uint8_t len_bit)
{
    // The naive sign conversion is safe and portable according to the C standard:
    // 6.3.1.3.3: if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more
    // than the maximum value that can be represented in the new type until the value is in the range of the new type.
    return nunavutSetUxx(buf, buf_size_bytes, off_bit, (uint64_t) value, len_bit);
}

static inline uint8_t nunavutGetU8(const uint8_t* const buf,
                                   const {{ typename_unsigned_length }} buf_size_bytes,
                                   const {{ typename_unsigned_bit_length }} off_bit,
                                   const uint8_t len_bit);

static inline bool nunavutGetBit(const uint8_t* const buf,
                                 const {{ typename_unsigned_length }} buf_size_bytes,
                                 const {{ typename_unsigned_bit_length }} off_bit)
{
    return 1U == nunavutGetU8(buf, buf_size_bytes, off_bit, 1U);
}

static inline uint8_t nunavutGetU8(const uint8_t* const buf,
                                   const {{ typename_unsigned_length }} buf_size_bytes,
                                   const {{ typename_unsigned_bit_length }} off_bit,
                                   const uint8_t len_bit)
{
    {{ assert('buf != NULL') }}
    const {{ typename_unsigned_bit_length }} copy_size = {# -#}
        _nunavutInternalGetBitCopySize(buf_size_bytes, off_bit, len_bit, 8U);
    {{ assert('copy_size <= (sizeof(uint8_t) * 8U)') }}
    uint8_t val = 0;
    nunavutCopyBits(copy_size, off_bit, 0U, buf, &val);
    return val;
}

static inline uint16_t nunavutGetU16(const uint8_t* const buf,
                                     const {{ typename_unsigned_length }} buf_size_bytes,
                                     const {{ typename_unsigned_bit_length }} off_bit,
                                     const uint8_t len_bit)
{
    {{ assert('buf != NULL') }}
    const {{ typename_unsigned_bit_length }} copy_size = {# -#}
        _nunavutInternalGetBitCopySize(buf_size_bytes, off_bit, len_bit, 16U);
    {{ assert('copy_size <= (sizeof(uint16_t) * 8U)') }}
{%- if option_target_endianness == 'little' %}
    uint16_t val = 0U;
    nunavutCopyBits(copy_size, off_bit, 0U, buf, (uint8_t*) &val);
    return val;
{%- elif option_target_endianness in ('any', 'big') %}
    uint8_t tmp[sizeof(uint16_t)] = {0};
    nunavutCopyBits(copy_size, off_bit, 0U, buf, &tmp[0]);
    return (uint16_t)(tmp[0] | (uint16_t)(((uint16_t) tmp[1]) << 8U));
{%- else %}{%- assert False %}
{%- endif %}
}

static inline uint32_t nunavutGetU32(const uint8_t* const buf,
                                     const {{ typename_unsigned_length }} buf_size_bytes,
                                     const {{ typename_unsigned_bit_length }} off_bit,
                                     const uint8_t len_bit)
{
    {{ assert('buf != NULL') }}
    const {{ typename_unsigned_bit_length }} copy_size = {# -#}
        _nunavutInternalGetBitCopySize(buf_size_bytes, off_bit, len_bit, 32U);
    {{ assert('copy_size <= (sizeof(uint32_t) * 8U)') }}
{%- if option_target_endianness == 'little' %}
    uint32_t val = 0U;
    nunavutCopyBits(copy_size, off_bit, 0U, buf, (uint8_t*) &val);
    return val;
{%- elif option_target_endianness in ('any', 'big') %}
    uint8_t tmp[sizeof(uint32_t)] = {0};
    nunavutCopyBits(copy_size, off_bit, 0U, buf, &tmp[0]);
    return (uint32_t)(tmp[0] | ((uint32_t) tmp[1] << 8U) | ((uint32_t) tmp[2] << 16U) | ((uint32_t) tmp[3] << 24U));
{%- else %}{%- assert False %}
{%- endif %}
}

static inline uint64_t nunavutGetU64(const uint8_t* const buf,
                                     const {{ typename_unsigned_length }} buf_size_bytes,
                                     const {{ typename_unsigned_bit_length }} off_bit,
                                     const uint8_t len_bit)
{
    {{ assert('buf != NULL') }}
    const {{ typename_unsigned_bit_length }} copy_size = {# -#}
        _nunavutInternalGetBitCopySize(buf_size_bytes, off_bit, len_bit, 64U);
    {{ assert('copy_size <= (sizeof(uint64_t) * 8U)') }}
{%- if option_target_endianness == 'little' %}
    uint64_t val = 0U;
    nunavutCopyBits(copy_size, off_bit, 0U, buf, (uint8_t*) &val);
    return val;
{%- elif option_target_endianness in ('any', 'big') %}
    uint8_t tmp[sizeof(uint64_t)] = {0};
    nunavutCopyBits(copy_size, off_bit, 0U, buf, &tmp[0]);
    return (uint64_t)(tmp[0] |
                      ((uint64_t) tmp[1] << 8U) |
                      ((uint64_t) tmp[2] << 16U) |
                      ((uint64_t) tmp[3] << 24U) |
                      ((uint64_t) tmp[4] << 32U) |
                      ((uint64_t) tmp[5] << 40U) |
                      ((uint64_t) tmp[6] << 48U) |
                      ((uint64_t) tmp[7] << 56U));
{%- else %}{%- assert False %}
{%- endif %}
}

static inline int8_t nunavutGetI8(const uint8_t* const buf,
                                  const {{ typename_unsigned_length }} buf_size_bytes,
                                  const {{ typename_unsigned_bit_length }} off_bit,
                                  const uint8_t len_bit)
{
    const uint8_t sat = (uint8_t) {{ choose_min('len_bit', '8U') }};
    uint8_t       val = nunavutGetU8(buf, buf_size_bytes, off_bit, sat);
    const bool    neg = (sat > 0U) && ((val & (1ULL << (sat - 1U))) != 0U);
    val = ((sat < 8U) && neg) ? (uint8_t)(val | ~((1U << sat) - 1U)) : val;  // Sign extension
    return neg ? (int8_t)((-(int8_t)(uint8_t) ~val) - 1) : (int8_t) val;
}

static inline int16_t nunavutGetI16(const uint8_t* const buf,
                                    const {{ typename_unsigned_length }} buf_size_bytes,
                                    const {{ typename_unsigned_bit_length }} off_bit,
                                    const uint8_t len_bit)
{
    const uint8_t sat = (uint8_t) {{ choose_min('len_bit', '16U') }};
    uint16_t      val = nunavutGetU16(buf, buf_size_bytes, off_bit, sat);
    const bool    neg = (sat > 0U) && ((val & (1ULL << (sat - 1U))) != 0U);
    val = ((sat < 16U) && neg) ? (uint16_t)(val | ~((1U << sat) - 1U)) : val;  // Sign extension
    return neg ? (int16_t)((-(int16_t)(uint16_t) ~val) - 1) : (int16_t) val;
}

static inline int32_t nunavutGetI32(const uint8_t* const buf,
                                    const {{ typename_unsigned_length }} buf_size_bytes,
                                    const {{ typename_unsigned_bit_length }} off_bit,
                                    const uint8_t len_bit)
{
    const uint8_t sat = (uint8_t) {{ choose_min('len_bit', '32U') }};
    uint32_t      val = nunavutGetU32(buf, buf_size_bytes, off_bit, sat);
    const bool    neg = (sat > 0U) && ((val & (1ULL << (sat - 1U))) != 0U);
    val = ((sat < 32U) && neg) ? (uint32_t)(val | ~((1UL << sat) - 1U)) : val;  // Sign extension
    return neg ? (int32_t)((-(int32_t) ~val) - 1) : (int32_t) val;
}

static inline int64_t nunavutGetI64(const uint8_t* const buf,
                                    const {{ typename_unsigned_length }} buf_size_bytes,
                                    const {{ typename_unsigned_bit_length }} off_bit,
                                    const uint8_t len_bit)
{
    const uint8_t sat = (uint8_t) {{ choose_min('len_bit', '64U') }};
    uint64_t      val = nunavutGetU64(buf, buf_size_bytes, off_bit, sat);
    const bool    neg = (sat > 0U) && ((val & (1ULL << (sat - 1U))) != 0U);
    val = ((sat < 64U) && neg) ? (uint64_t)(val | ~((1ULL << sat) - 1U)) : val;  // Sign extension
    return neg ? (int64_t)((-(int64_t) ~val) - 1) : (int64_t) val;
}

{%- if not option_omit_float_serialization_support %}

// --------------------------------------------- PUBLIC API - FLOAT16 ---------------------------------------------

static_assert(NUNAVUT_PLATFORM_IEEE754_FLOAT,
              "The target platform does not support IEEE754 floating point operations.");
static_assert(32U == (sizeof({{typename_float_32}}) * 8U), "Unsupported floating point model");

/// Converts a single-precision float into the binary representation of the value as a half-precision IEEE754 value.
static inline uint16_t nunavutFloat16Pack(const {{typename_float_32}} value)
{
    {{ float32_union() }}

    // The no-lint statements suppress the warning about the use of union. This is required for low-level bit access.
    const uint32_t round_mask = ~(uint32_t) 0x0FFFU;
    Float32Bits    f32inf;  // NOSONAR
    Float32Bits    f16inf;  // NOSONAR
    Float32Bits    magic;   // NOSONAR
    Float32Bits    in;      // NOSONAR
    f32inf.bits = ((uint32_t) 255U) << 23U;
    f16inf.bits = ((uint32_t) 31U) << 23U;
    magic.bits = ((uint32_t) 15U) << 23U;
    in.real = value;
    const uint32_t sign = in.bits & (((uint32_t) 1U) << 31U);
    in.bits ^= sign;
    uint16_t out = 0;
    if (in.bits >= f32inf.bits)
    {
        if ((in.bits & 0x7FFFFFUL) != 0)
        {
            out = 0x7E00U;
        }
        else
        {
            out = (in.bits > f32inf.bits) ? (uint16_t) 0x7FFFU : (uint16_t) 0x7C00U;
        }
    }
    else
    {
        in.bits &= round_mask;
        in.real *= magic.real;
        in.bits -= round_mask;
        if (in.bits > f16inf.bits)
        {
            in.bits = f16inf.bits;
        }
        out = (uint16_t)(in.bits >> 13U);
    }
    out |= (uint16_t)(sign >> 16U);
    return out;
}

static inline {{typename_float_32}} nunavutFloat16Unpack(const uint16_t value)
{
    {{ float32_union() }}

    // The no-lint statements suppress the warning about the use of union. This is required for low-level bit access.
    Float32Bits magic;    // NOSONAR
    Float32Bits inf_nan;  // NOSONAR
    Float32Bits out;      // NOSONAR
    magic.bits = ((uint32_t) 0xEFU) << 23U;
    inf_nan.bits = ((uint32_t) 0x8FU) << 23U;
    out.bits = ((uint32_t)(value & 0x7FFFU)) << 13U;
    out.real *= magic.real;
    if (out.real >= inf_nan.real)
    {
        out.bits |= ((uint32_t) 0xFFU) << 23U;
    }
    out.bits |= ((uint32_t)(value & 0x8000U)) << 16U;
    return out.real;
}

static inline {{typename_error_type}} nunavutSetF16(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const {{ typename_float_32 }} value)
{
    return nunavutSetUxx(buf, buf_size_bytes, off_bit, nunavutFloat16Pack(value), 16U);
}

static inline {{typename_float_32}} nunavutGetF16(
    const uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit)
{
    return nunavutFloat16Unpack(nunavutGetU16(buf, buf_size_bytes, off_bit, 16U));
}

// --------------------------------------------- PUBLIC API - FLOAT32 ---------------------------------------------

static_assert(NUNAVUT_PLATFORM_IEEE754_FLOAT,
              "The target platform does not support IEEE754 floating point operations.");
static_assert(32U == (sizeof({{typename_float_32}}) * 8U), "Unsupported floating point model");

static inline {{typename_error_type}} nunavutSetF32(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const {{ typename_float_32 }} value)
{
    // Intentional violation of MISRA: use union to perform fast conversion from an IEEE 754-compatible native
    // representation into a serializable integer. The assumptions about the target platform properties are made
    // clear. In the future we may add a more generic conversion that is platform-invariant.
    union  // NOSONAR
    {
        {{typename_float_32}} fl;
        uint32_t in;
    } const tmp = {value};  // NOSONAR
    return nunavutSetUxx(buf, buf_size_bytes, off_bit, tmp.in, sizeof(tmp) * 8U);
}

static inline {{typename_float_32}} nunavutGetF32(
    const uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit)
{
    // Intentional violation of MISRA: use union to perform fast conversion to an IEEE 754-compatible native
    // representation into a serializable integer. The assumptions about the target platform properties are made
    // clear. In the future we may add a more generic conversion that is platform-invariant.
    union  // NOSONAR
    {
        uint32_t in;
        {{typename_float_32}} fl;
    } const tmp = {nunavutGetU32(buf, buf_size_bytes, off_bit, 32U)};
    return tmp.fl;
}

// --------------------------------------------- PUBLIC API - FLOAT64 ---------------------------------------------

static_assert(NUNAVUT_PLATFORM_IEEE754_DOUBLE,
              "The target platform does not support IEEE754 double-precision floating point operations.");
static_assert(64U == (sizeof({{typename_float_64}}) * 8U), "Unsupported floating point model");

static inline {{typename_error_type}} nunavutSetF64(
    uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit,
    const {{typename_float_64 }} value)
{
    // Intentional violation of MISRA: use union to perform fast conversion from an IEEE 754-compatible native
    // representation into a serializable integer. The assumptions about the target platform properties are made
    // clear. In the future we may add a more generic conversion that is platform-invariant.
    union  // NOSONAR
    {
        {{typename_float_64}} fl;
        uint64_t in;
    } const tmp = {value};  // NOSONAR
    return nunavutSetUxx(buf, buf_size_bytes, off_bit, tmp.in, sizeof(tmp) * 8U);
}

static inline {{typename_float_64}} nunavutGetF64(
    const uint8_t* const buf,
    const {{ typename_unsigned_length }} buf_size_bytes,
    const {{ typename_unsigned_bit_length }} off_bit)
{
    // Intentional violation of MISRA: use union to perform fast conversion to an IEEE 754-compatible native
    // representation into a serializable integer. The assumptions about the target platform properties are made
    // clear. In the future we may add a more generic conversion that is platform-invariant.
    union  // NOSONAR
    {
        uint64_t in;
        {{typename_float_64}} fl;
    } const tmp = {nunavutGetU64(buf, buf_size_bytes, off_bit, 64U)};
    return tmp.fl;
}

{% endif -%}

#ifdef __cplusplus
}
#endif

#endif /* NUNAVUT_SUPPORT_SERIALIZATION_H_INCLUDED */
